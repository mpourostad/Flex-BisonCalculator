%{
#include <iostream>
#include <cmath>
#include "util.h"


int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    float val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog

%token LPAREN RPAREN
%token PLUS MINUS MUL DIV MOD POW SQRT FACTORIAL EQUALS LOG10 LOG2
%token ABS FLOOR CEIL PI
%token SIN COS TAN
%token VARIABLE_KEYWORD VARIABLE
%token EURO_TO_USD CEL_TO_FAH FAH_TO_CEL MI_TO_KM KM_TO_MI
USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO GBP_TO_USD

%token <val> NUM    /* 'val' is the (only) field declared in %union
                       which represents the type of the token. */

%type <val> expr

/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left PLUS MINUS    /* left means left-associativity. */
%left DIV MUL
%left POW 
%left FACTORIAL

%%

prog : expr                             { std::cout << $1 << std::endl; }
     ;

expr : expr PLUS expr                   { $$ = $1 + $3; }
     | expr MINUS expr                  { $$ = $1 - $3; }
     | expr MUL expr                    { $$ = $1 * $3; }
     | expr DIV expr                    { $$ = $1 / $3; }
     | expr MOD expr                    { $$ = modulo($1, $3); }
     | expr POW expr                    { $$ = pow($1, $3); }
     | expr EQUALS                      {$$ = $1; }
     | NUM                              /* default action: { $$ = $1; } */
     | LPAREN expr RPAREN               { $$ = $2; }
     | PI                               { $$ = 3.14; }
     | EQUALS                           { printf("GOOOOH") }//{ printf("\tGOOOOH: %i\n", $1); }//
     | SQRT LPAREN expr RPAREN          { $$ = sqrt($3); }
     | expr FACTORIAL                   { $$ = factorial($1); }
     | ABS LPAREN expr RPAREN           { $$ = abs($3); }
     | LOG10 expr                       { $$ = log($3) / log(10); }
     | LOG2  expr                       { $$ = log($2) / log(2); }
     | FLOOR LPAREN expr RPAREN         { $$ = floor($3); }
     | CEIL LPAREN expr RPAREN          { $$ = ceil($3); }
     | GBP_TO_USD LPAREN expr RPAREN    { $$ = gbp_to_usd($3); }
     | USD_TO_GBP LPAREN expr RPAREN    { $$ = usd_to_gbp($3); }
     | GBP_TO_EURO LPAREN expr RPAREN    { $$ = gbp_to_euro($3); }
     | EURO_TO_GBP LPAREN expr RPAREN    { $$ = euro_to_gbp($3); }
     | USD_TO_EURO LPAREN expr RPAREN    { $$ = usd_to_euro($3); }
     | EURO_TO_USD LPAREN expr RPAREN    { $$ = euro_to_usd($3); }
     | CEL_TO_FAH LPAREN expr RPAREN    { $$ = cel_to_fah($3); }
     | FAH_TO_CEL LPAREN expr RPAREN    { $$ = fah_to_cel($3); }
     | MI_TO_KM LPAREN expr RPAREN    { $$ = m_to_km($3); }
     | KM_TO_MI LPAREN expr RPAREN    { $$ = km_to_m($3); }
     | SIN LPAREN expr RPAREN          { $$ = sin($3); }
     | COS LPAREN expr RPAREN          { $$ = cos($3); }
     | TAN LPAREN expr RPAREN          { $$ = sin($3)/cos($3); }
     | PLUS expr                       {$$ = $2; }

    
     ;
%%
int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
